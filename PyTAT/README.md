# PyTAT

PyTAT is python binding for [TAT](https://github.com/hzhangxyz/TAT),
which is a c++ tensor library with support for symmetry tensor.

Its interface for symmetry tensor and normal tensor are similar,
so first, let us introduce normal tensor interface of PyTAT.

## No Symemtry Tensor

No Symmetry Tensor is a tensor without any symmetry,
which is just a normal tensor, so let us begin from this.

NoTAT is a subset of PyTAT with only normal tensor support,
which means if you use only no symmetry tensor, you can replace
`import TAT` to `import NoTAT as TAT` for light weight package

### Create tensor

Here is a example to create a tensor.

```py
# Import package before any other things
import TAT

# TAT does not support mixing different basic scalar type tensor
# So you need to get type of some specific type tensor first
# Supported type are "float", "float32", "complex", "complex32"
Tensor = TAT(float)

# Create a rank-2 tensor with edge names as "i" and "j", and its
# dimension is 3 and 4
A = Tensor(["i", "j"], [3, 4])

# Print the tensor A, please notice that TAT will NOT initialize
# content of tensor to zero
print(A)

# str(A) will show all the content of tensor A, and repr(A) will only
# show the dimension information
print(repr(A))
```

### Tensor and numpy array

TAT can use [buffer protocal](https://docs.python.org/3/c-api/buffer.html)
to communicate with numpy.

```py
# Import numpy
import numpy as np

# Export tensor to numpy array, which shape is [4, 3], because the
# dimension order is set as `["j", "i"]`, where "i" correspond to an
# edge with dimension 3 and "j" correspond to an edge with dimension
# 4, so the result shape is `4*3`.
data_A = A.block[["j", "i"]]

# Result is `(4, 3)`
print(data_A.shape)
```

You can directly modify numpy array `data_A` to change data of tensor A.

```py
# Set element of data_A
data_A[1, 2] = 233

# print corresponding element of tensor A, you will get `233.0`
# This expression means choose the second index of edge "i"
# and the first index of edge "j"
print(A[{"i": 2, "j": 1}])
```

You can also direcly set `A.block[...]` to a numpy array.

```py
# Set the whole tensor data to a numpy array
A.block[["j", "i"]] = np.random.rand(4, 3)

# It will NOT update tensor A because data_A is a new variable.
# You can use `A.block[[...]][...] = ...`,
# `data_A = A.block[[...]]; data_A[...] = ...` or
# `A.block[[...]] = ...` but not
# `data_A = A.block[[...]]; data_A = ...
data_A = np.random.rand(4, 3)
```

### Scalar operator

You can do scalar operator direclty.

```py
# Create two rank-1 tensors
A = Tensor(["i"], [4])
A.block[["i"]] = [1, 2, 3, 4]
B = Tensor(["i"], [4])
B.block[["i"]] = [1, 2, 3, 4]

# Add two tensor
print(A + B)

# number over a tensor
print(1 / A)

# Create two rank-2 tensors
C = Tensor(["i", "j"], [2, 2])
C.block[["i", "j"]] = [[1, 2], [3, 4]]
D = Tensor(["j", "i"], [2, 2])
D.block[["j", "i"]] = [[1, 2], [3, 4]]

# scalar operator of two tensor will check edge name
# of two tensor and transpose them to the same first.
print(C + D)
```

### Rank-0 tensor and number

You can convert between rank-0 tensor and python number directly

```py
# Directly initialize a tensor with a number
A = Tensor(233)
print(A)

# Convert rank-0 tensor to python number
a = float(A)
print(a)
```

### Deep copy

```py
A = Tensor(233)
B = A
A[{}] = 1
# data of B is also change when execute `A[{}] = 1`, since A
# and B share data
print(float(B))

A = Tensor(233)
# Deep copy of tensor A
B = A.copy()
A[{}] = 1
# data of B is still 233
print(float(B))
```

### Create same shape tensor

```py
A = Tensor(["i", "j"], [2, 2])
A.block[["i", "j"]] = [[1, 2], [3, 4]]
# B copy the shape of A but not content of A
B = A.same_shape()
print(B)
```

### Map and transform

```py
A = Tensor(["i", "j"], [2, 2])
A.block[["i", "j"]] = [[1, 2], [3, 4]]
# Every element is transformed by a function inplacely
A.transform(lambda x: x * x)
print(A)

# Every element is transformed by a function outplacely
B = A.map(lambda x: x + 1)
print(B)
print(A)

# Please note the this two functions call python function,
# So the speed may be an issue. a commonly used routine is
# sqrt, so TAT implement it builtin.
C = A.sqrt()
print(C)
```

### Miscellaneous setter functions

```py
# Create a tensor and set it to zero inplacely
A = Tensor(["i", "j"], [2, 2])
A.zero()

# Or directly write them in one line
A = Tensor(["i", "j"], [2, 2]).zero()

# Fill meanless test data into tensor
A = Tensor(["i", "j"], [2, 2]).test()

# Fill data generated by a function
A = Tensor(["i", "j"], [2, 2]).set(lambda :233)
```

### Type conversion

```py
A = Tensor(233)
# Type of A is <class 'TAT.Tensor.DNo'>
print(type(A))
# Convert A to an complex tensor
B = A.to(complex)
# Type of B is <class 'TAT.Tensor.ZNo'>
print(type(B))
```

### Norm

```py
A = Tensor(["i"], [10]).test()
# Get maximum norm
print(A.norm_max())
# Get 0 norm
print(A.norm_num())
# Get 1 norm
print(A.norm_sum())
# Get 2 norm
print(A.norm_2())
```

### Contract

```py
A = Tensor(["i", "j", "k"], [2, 3, 4]).test()
B = Tensor(["a", "b", "c", "d"], [2, 5, 3, 6]).test()
# Contract edge i of A and edge a of B, edge j of A and edge c of B
C = A.contract(B, {("i", "a"), ("j", "c")})
# Output is `DNoTensor{names:[k,b,d],edges:[4,5,6]}`
print(repr(C))
```

### Merge and split edge

```py
A = Tensor(["i", "j", "k"], [2, 3, 4]).test()
# Merge edge i and edge j into a single edge a,
# and Merge no edge to get a trivial edge b
B = A.merge_edge({"a": ["i", "j"], "b": []})
# Output is `DNoTensor{names:[b,a,k],edges:[1,6,4]}`
print(repr(B))

# Split edge a back to edge i and edge j, and split
# trivial edge b to no edge
C = B.split_edge({"b": [], "a": [("i", 2), ("j", 3)]})
# Output is `DNoTensor{names:[i,j,k],edges:[2,3,4]}`
print(repr(C))
```

### Edge rename and transpose

```py
A = Tensor(["i", "j", "k"], [2, 3, 4]).test()
# Rename edge i to edge x
B = A.edge_rename({"i": "x"})
print(repr(B))
# `edge_rename` is an outplace operator
print(repr(A))

# Transpose tensor A with specific order
C = A.transpose(["k", "j", "i"])
print(repr(C))
```

### SVD and QR decomposition

```py
A = Tensor(["i", "j", "k"], [2, 3, 4]).test()
# Do QR decomposition, specify Q matrix edge is edge k
# You can also write is as `Q, R = A.qr('r', {"i", "j"}, "Q", "R")`
# The last two argument is the name of new edges generated
# by QR decomposition
Q, R = A.qr('q', {"k"}, "Q", "R")
# Q is an unitary matrix, which edge name is Q and k
print(Q.edge_rename({"Q": "Q1"}).contract(Q.edge_rename({"Q": "Q2"}), {("k", "k")}).block[["Q1", "Q2"]])
# Q R - A is 0
print((Q.contract(R, {("Q", "R")}) - A).norm_max())


# Do SVD decomposition with cut=3, if cut not specified,
# svd will not cut the edge.
# The first argument is edge set of matrix U, SVD does not
# supply function to specify edge set of matrix V like what
# is done in QR since SVD is symmetric between U and V.
# The later two argument is new edges generated
U, S, V = A.svd({"k"}, "U", "V", cut=3)
# U is an rank-3 unitary matrix
print(U.edge_rename({"U": "U1"}).contract(U.edge_rename({"U": "U2"}), {("k", "k")}).block[["U1", "U2"]])
# U S V - A is a small value
# please notice that S is an diagnalized matrix so contract is
# not support, use multiple which is designed for this
# situation instead. Its interface is
# `matrix_U.multiple(Singular, matrix_U_edge_name, 'u')` or
# `matrix_V.multiple(Singular, matrix_V_edge_name, 'v')`,
# multiple is an outplace operator
print((U.multiple(S, "U", 'u').contract(V, {("U", "V")}) - A).norm_max())

# Here A is a real tensor, if it is complex tensor, you may
# need outplace operator `U.conjugate()` to get conjugate
# tensor of unitary matrix
```

### Identity, exponential and trace

```py
# Please notice that identity is INPLACE operator
# For any i, j, k, l, we have
# `A[{"i":i, "j":j, "k":k, "l":l}] = delta(i,l) * delta(j,k)`
A = Tensor(["i","j","k","l"],[2,3,3,2]).identity({("i", "l"), ("j", "k")})

# calculate matrix exponential B = exp(A)
# step is iteration steps, with default value 2
B = A.exponential({("i", "l"), ("j", "k")}, step=4)

# Calculate trace or partial trace of a tenso
# Here it calculate `A[{"i":i, "j":j, "k":k, "l":l}] * delta(i,l) * delta(j,k)`
C = A.trace({("i", "l"), ("j", "k")})
```

### Pickle

You can use pickle to load or dump tensor directly

```py
A = Tensor(["i","j","k","l"],[2,3,3,2]).test()

import pickle
# pickle dump a tensor and then load it
print(pickle.loads(pickle.dumps(A)))
```

### Random number generator

Although you can create random tensor by `set`, it may be slow, So
we implement a builtin random tensor generator.

```py
# Set random seed
TAT.random.seed(233)

# Generate uniform distribution data between 0 and 1
# into tensor A
A = Tensor(["i","j","k","l"],[2,3,3,2]).rand(0, 1)


# Generate normal distribution data with mean=0,
# stddev=1 into tensor A
A = Tensor(["i","j","k","l"],[2,3,3,2]).randn(0, 1)
```

### Shirnk and expand

```py
A = Tensor(["i","j","k","l"],[2,3,3,2]).rand(0, 1)
print(repr(A))
# Specify slice of tensor A
B = A.shrink({"i": 0, "j": 1})
print(repr(B))
# Output is an zero numpy array
print(A.block[["i","j","k","l"]][0, 1] - B.block[["k", "l"]])

# Reverse operation is expand
C = B.expand({"i": (0, 2), "j": (1, 3)})
print(repr(C))
```

## Symemtry Tensor

## Fermi Tensor

## FAQ

### I get error message like this when `import TAT`

```plain
mca_base_component_repository_open: unable to open mca_patcher_overwrite: /usr/lib/x86_64-linux-gnu/openmpi/lib/openmpi/mca_patcher_overwrite.so: undefined symbol: mca_patcher_base_patch_t_class (ignored)
mca_base_component_repository_open: unable to open mca_shmem_posix: /usr/lib/x86_64-linux-gnu/openmpi/lib/openmpi/mca_shmem_posix.so: undefined symbol: opal_shmem_base_framework (ignored)
mca_base_component_repository_open: unable to open mca_shmem_mmap: /usr/lib/x86_64-linux-gnu/openmpi/lib/openmpi/mca_shmem_mmap.so: undefined symbol: opal_show_help (ignored)
mca_base_component_repository_open: unable to open mca_shmem_sysv: /usr/lib/x86_64-linux-gnu/openmpi/lib/openmpi/mca_shmem_sysv.so: undefined symbol: opal_show_help (ignored)
```

It is a problem for some old mpi version(for example, openmpi 2.1.1 in ubuntu 18.04 LTS),
you need to load mpi dynamic shared library manually before `import TAT`,
The way to load it manually is `import ctypes` and `ctypes.CDLL("libmpi.so", mode=ctypes.RTLD_GLOBAL)`
